<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <title>Technical Documentation Page - freeCodeCamp</title>
  </head>
  <body>
    <nav id="navbar">
      <header>JS - Data Types</header>
      <ul>
        <li><a href="#Number" class="nav-link">Number</a></li>
        <li><a href="#BigInt" class="nav-link">BigInt</a></li>
        <li><a href="#String" class="nav-link">String</a></li>
        <li>
          <a href="#Boolean_logical_type" class="nav-link"
            >Boolean logical type</a
          >
        </li>
        <li><a href="#The_null_value" class="nav-link">The null value</a></li>
        <li>
          <a href="#Objects_and_Symbols" class="nav-link"
            >Objects and Symbols</a
          >
        </li>
        <li>
          <a href="#The_typeof_operator" class="nav-link"
            >The typeof operator</a
          >
        </li>
        <li><a href="#Summary" class="nav-link">Summary</a></li>
      </ul>
    </nav>
    <main id="main-doc">
      <header>
        <p>
          This is an only example for the HTML/CSS certification from
          freeCodeCamp. All data has been extracted from <a href="https://javascript.info/types" target="_blank" rel="noopener noreferrer">https://javascript.info/types</a>
        </p>
      </header>
      <section class="main-section" id="Number">
        <header>Number</header>
        <pre>
          <code>let n = 123;
            n = 12.345;
          </code>
        </pre>
        <p>
          The number type represents both integer and floating point numbers.
        </p>
        <p>
          There are many operations for numbers, e.g. multiplication *, division
          /, addition +, subtraction -, and so on.
        </p>
        <p>
          Besides regular numbers, there are so-called “special numeric values”
          which also belong to this data type: Infinity, -Infinity and NaN.
        </p>
        <ul>
          <li>
            Infinity represents the mathematical Infinity ∞. It is a special
            value that’s greater than any number.
          </li>
          <p>We can get it as a result of division by zero:</p>
          <pre>
            <code>alert( 1 / 0 ); <span>// Infinity</span></code>
          </pre>
          <p>Or just reference it directly:</p>
          <pre>
            <code>alert( Infinity ); <span>// Infinity</span></code>
          </pre>
          <li>
            NaN represents a computational error. It is a result of an incorrect
            or an undefined mathematical operation, for instance:
          </li>
          <pre>
            <code>alert( "not a number" / 2 ); <span>// NaN, such division is erroneous</span></code>
          </pre>
          <p>
            NaN is sticky. Any further mathematical operation on NaN returns
            NaN:
          </p>
          <pre>
            <code>alert( NaN + 1 ); <span>// NaN</span>
              alert( 3 * NaN ); <span>// NaN</span>
              alert( "not a number" / 2 - 1 ); <span>// NaN</span>
            </code>
          </pre>
          <p>
            So, if there’s a NaN somewhere in a mathematical expression, it
            propagates to the whole result (there’s only one exception to that:
            NaN ** 0 is 1).
          </p>
          <p>
            Special numeric values formally belong to the “number” type. Of
            course they are not numbers in the common sense of this word.
          </p>
          <p>
            We’ll see more about working with numbers in the chapter Numbers.
          </p>
        </ul>
      </section>
      <section class="main-section" id="BigInt">
        <header>BigInt</header>
        <p>
          In JavaScript, the “number” type cannot safely represent integer
          values larger than (253-1) (that’s 9007199254740991), or less than
          -(253-1) for negatives.
        </p>
        <p>
          To be really precise, the “number” type can store larger integers (up
          to 1.7976931348623157 * 10308), but outside of the safe integer range
          ±(253-1) there’ll be a precision error, because not all digits fit
          into the fixed 64-bit storage. So an “approximate” value may be
          stored.
        </p>
        <p>
          For example, these two numbers (right above the safe range) are the
          same:
        </p>
        <pre>
          <code>console.log(9007199254740991 + 1); <span>// 9007199254740992</span>
            console.log(9007199254740991 + 2); <span>// 9007199254740992</span>
          </code>
        </pre>
        <p>
          So to say, all odd integers greater than (253-1) can’t be stored at
          all in the “number” type.
        </p>
        <p>
          For most purposes ±(253-1) range is quite enough, but sometimes we
          need the entire range of really big integers, e.g. for cryptography or
          microsecond-precision timestamps.
        </p>
        <p>
          BigInt type was recently added to the language to represent integers
          of arbitrary length.
        </p>
        <p>
          A BigInt value is created by appending n to the end of an integer:
        </p>
        <pre>
          <code><span>//the "n" at the end means it's a BigInt</span>
            const bigInt = 1234567890123456789012345678901234567890n;
          </code>
        </pre>
        <p>
          As BigInt numbers are rarely needed, we don’t cover them here, but
          devoted them a separate chapter BigInt. Read it when you need such big
          numbers.
        </p>
        <p>
          You can check MDN BigInt compatibility table to know which versions of
          a browser are supported.
        </p>
      </section>
      <section class="main-section" id="String">
        <header>String</header>
        <p>A string in JavaScript must be surrounded by quotes.</p>
        <pre>
          <code>let str = "Hello";
            let str2 = 'Single quotes are ok too';
            let phrase = `can embed another ${str}`;
          </code>
        </pre>
        <p>In JavaScript, there are 3 types of quotes.</p>
        <ol>
          <li>Double quotes: "Hello".</li>
          <li>Single quotes: 'Hello'.</li>
          <li>Backticks: `Hello`.</li>
        </ol>
        <p>
          Double and single quotes are “simple” quotes. There’s practically no
          difference between them in JavaScript.
        </p>
        <p>
          Backticks are “extended functionality” quotes. They allow us to embed
          variables and expressions into a string by wrapping them in ${…}, for
          example:
        </p>
        <pre>
          <code>let name = "John";

            <span>// embed a variable</span>
            alert( `Hello, ${name}!` ); <span>// Hello, John!</span>

            <span>// embed an expression</span>
            alert( `the result is ${1 + 2}` ); <span>// the result is 3</span>
          </code>
        </pre>
        <p>
          The expression inside ${…} is evaluated and the result becomes a part
          of the string. We can put anything in there: a variable like name or
          an arithmetical expression like 1 + 2 or something more complex.
        </p>
        <p>
          Please note that this can only be done in backticks. Other quotes
          don’t have this embedding functionality!
        </p>
        <pre>
          <code>alert( "the result is ${1 + 2}" ); <span>// the result is ${1 + 2} (double quotes do nothing)</span></code>
        </pre>
        <p>We’ll cover strings more thoroughly in the chapter Strings.</p>
      </section>
      <section class="main-section" id="Boolean_logical_type">
        <header>Boolean logical type</header>
        <p>The boolean type has only two values: true and false.</p>
        <p>
          This type is commonly used to store yes/no values: true means “yes,
          correct”, and false means “no, incorrect”.
        </p>
        <p>For instance:</p>
        <pre>
          <code>let nameFieldChecked = true; <span>// yes, name field is checked</span>
            let ageFieldChecked = false; <span>// no, age field is not checked</span>
          </code>
        </pre>
        <p>Boolean values also come as a result of comparisons:</p>
        <pre>
          <code>let isGreater = 4 > 1;

            alert( isGreater ); <span>// true (the comparison result is "yes")</span>
          </code>
        </pre>
        <p>
          We’ll cover booleans more deeply in the chapter Logical operators.
        </p>
      </section>
      <section class="main-section" id="The_null_value">
        <header>The null value</header>
        <p>
          The special null value does not belong to any of the types described
          above.
        </p>
        <p>
          It forms a separate type of its own which contains only the null
          value:
        </p>
        <pre>
          <code>let age = null;</code>
        </pre>
        <p>
          In JavaScript, null is not a “reference to a non-existing object” or a
          “null pointer” like in some other languages.
        </p>
        <p>
          It’s just a special value which represents “nothing”, “empty” or
          “value unknown”.
        </p>
        <p>The code above states that age is unknown.</p>
      </section>
      <section class="main-section" id="Objects_and_Symbols">
        <header>Objects and Symbols</header>
        <p>
          The special value undefined also stands apart. It makes a type of its
          own, just like null.
        </p>
        <p>The meaning of undefined is “value is not assigned”.</p>
        <p>
          If a variable is declared, but not assigned, then its value is
          undefined:
        </p>
        <pre>
          <code>let age;

            alert(age); <span>// shows "undefined"</span>
          </code>
        </pre>
      </section>
      <section class="main-section" id="The_typeof_operator">
        <header>The typeof operator</header>
        <p>
          The typeof operator returns the type of the argument. It’s useful when
          we want to process values of different types differently or just want
          to do a quick check.
        </p>
        <p>A call to typeof x returns a string with the type name:</p>
        <pre>
          <code>typeof undefined <span>// "undefined"</span>

            typeof 0 <span>// "number"</span>

            typeof 10n <span>// "bigint"</span>

            typeof true <span>// "boolean"</span>

            typeof "foo" <span>// "string"</span>

            typeof Symbol("id") <span>// "symbol"</span>

            typeof Math <span>// "object"  (1)</span>

            typeof null <span>// "object"  (2)</span>

            typeof alert <span>// "function"  (3)</span>
          </code>
        </pre>
        <p>The last three lines may need additional explanation:</p>
        <ol>
          <li>
            Math is a built-in object that provides mathematical operations. We
            will learn it in the chapter Numbers. Here, it serves just as an
            example of an object.
          </li>
          <li>
            The result of typeof null is "object". That’s an officially
            recognized error in typeof, coming from very early days of
            JavaScript and kept for compatibility. Definitely, null is not an
            object. It is a special value with a separate type of its own. The
            behavior of typeof is wrong here.
          </li>
          <li>
            The result of typeof alert is "function", because alert is a
            function. We’ll study functions in the next chapters where we’ll
            also see that there’s no special “function” type in JavaScript.
            Functions belong to the object type. But typeof treats them
            differently, returning "function". That also comes from the early
            days of JavaScript. Technically, such behavior isn’t correct, but
            can be convenient in practice.
          </li>
        </ol>
      </section>
      <section class="main-section" id="Summary">
        <header>Summary</header>
        <p>There are 8 basic data types in JavaScript.</p>
        <ul>
          <li>Seven primitive data types:</li>
          <ul>
            <li>
              number for numbers of any kind: integer or floating-point,
              integers are limited by ±(253-1).
            </li>
            <li>bigint for integer numbers of arbitrary length.</li>
            <li>
              string for strings. A string may have zero or more characters,
              there’s no separate single-character type.
            </li>
            <li>boolean for true/false.</li>
            <li>
              null for unknown values – a standalone type that has a single
              value null.
            </li>
            <li>
              undefined for unassigned values – a standalone type that has a
              single value undefined.
            </li>
            <li>symbol for unique identifiers.</li>
          </ul>
          <li>And one non-primitive data type:</li>
          <ul>
            <li>object for more complex data structures.</li>
          </ul>
        </ul>
        <p>
          The typeof operator allows us to see which type is stored in a
          variable.
        </p>
        <ul>
          <li>Usually used as typeof x, but typeof(x) is also possible.</li>
          <li>Returns a string with the name of the type, like "string".</li>
          <li>
            For null returns "object" – this is an error in the language, it’s
            not actually an object.
          </li>
        </ul>
      </section>
    </main>
  </body>
</html>
